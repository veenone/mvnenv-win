{
  "id": "snapshot_1760275953150_r5eae89qo",
  "approvalId": "approval_1760253688139_pl14pvyn1",
  "approvalTitle": "Shim System Implementation - Design Document",
  "version": 2,
  "timestamp": "2025-10-12T13:32:33.150Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Architecture Overview\n\nThe Shim System provides transparent Maven command interception through lightweight proxy executables that resolve the active Maven version and forward commands to the appropriate installation. The architecture uses a single shim executable that determines which command was invoked based on its filename, resolves the version, and executes the target Maven command with full I/O pass-through.\n\n### Core Design Principles\n\n1. **Minimal Overhead**: Shim adds <50ms overhead through efficient version resolution and direct process spawning\n2. **Transparent Operation**: Users interact with Maven commands normally; shims are invisible\n3. **Single Binary**: One shim executable serves all Maven commands (mvn, mvnDebug, mvnyjp) via filename detection\n4. **Zero Buffering**: Direct I/O forwarding without buffering ensures real-time output\n5. **Fail Fast**: Clear error messages at resolution time prevent confusing Maven errors\n\n## Component Architecture\n\n```\ncmd/shim/\n└── main.go                # Shim executable entry point\n\ninternal/shim/\n├── generator.go           # ShimGenerator creates shim files\n├── executor.go            # ShimExecutor handles command execution\n├── resolver.go            # Integrates with VersionResolver\n└── path_windows.go        # Windows-specific PATH management\n```\n\n### Component Relationships\n\n```\nUser types \"mvn clean\"\n         ↓\n    Shim Executable (mvn.exe)\n         ↓\n    Detect Command (from filename)\n         ↓\n    ShimExecutor.Execute()\n         ↓\n    VersionResolver.ResolveVersion() ←── from core-version-management\n         ↓\n    Construct Maven Path\n         ↓\n    Set MAVEN_HOME\n         ↓\n    os/exec.Command with I/O forwarding\n         ↓\n    Maven Process Execution\n         ↓\n    Exit with Maven's exit code\n```\n\n## Detailed Component Design\n\n### 1. Shim Executable (cmd/shim/main.go)\n\nThe main entry point for the shim executable. This is the actual binary that gets invoked when users run `mvn`, `mvnDebug`, etc.\n\n```go\n// cmd/shim/main.go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n\n    \"github.com/veenone/mvnenv-win/internal/shim\"\n    \"github.com/veenone/mvnenv-win/internal/version\"\n)\n\nfunc main() {\n    // Detect command name from executable name\n    command := detectCommand()\n\n    // Create executor with version resolver\n    resolver := version.NewVersionResolver()\n    executor := shim.NewShimExecutor(resolver)\n\n    // Execute Maven command\n    exitCode, err := executor.Execute(command, os.Args[1:])\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"mvnenv: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    os.Exit(exitCode)\n}\n\n// detectCommand determines which Maven command was invoked\n// by examining the executable filename (mvn.exe -> \"mvn\")\nfunc detectCommand() string {\n    exePath, err := os.Executable()\n    if err != nil {\n        return \"mvn\" // default fallback\n    }\n\n    base := filepath.Base(exePath)\n    // Remove .exe extension if present\n    name := strings.TrimSuffix(base, \".exe\")\n    return name\n}\n```\n\n**Key Design Decisions:**\n- Single binary approach: reduces code duplication and simplifies updates\n- Filename-based detection: allows same executable to serve multiple commands\n- Minimal dependencies: only uses internal packages and standard library\n- Direct exit: preserves Maven's exit code exactly\n\n### 2. ShimGenerator\n\nGenerates shim executable files and manages the shims directory.\n\n```go\n// internal/shim/generator.go\npackage shim\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n)\n\n// ShimGenerator creates and manages Maven command shims\ntype ShimGenerator struct {\n    shimsDir     string // %USERPROFILE%\\.mvnenv\\shims\n    shimBinary   string // Path to shim.exe\n    versionsDir  string // %USERPROFILE%\\.mvnenv\\versions\n}\n\n// NewShimGenerator creates a shim generator\nfunc NewShimGenerator(mvnenvRoot string) *ShimGenerator {\n    return &ShimGenerator{\n        shimsDir:    filepath.Join(mvnenvRoot, \"shims\"),\n        shimBinary:  filepath.Join(mvnenvRoot, \"bin\", \"shim.exe\"),\n        versionsDir: filepath.Join(mvnenvRoot, \"versions\"),\n    }\n}\n\n// GenerateShims creates shim executables for all Maven commands\n// Returns list of generated shim paths or error\nfunc (g *ShimGenerator) GenerateShims() ([]string, error) {\n    // Ensure shims directory exists\n    if err := os.MkdirAll(g.shimsDir, 0755); err != nil {\n        return nil, fmt.Errorf(\"create shims directory: %w\", err)\n    }\n\n    // Core Maven commands to shim\n    commands := []string{\"mvn\", \"mvnDebug\"}\n\n    // Scan installed versions for additional commands (mvnyjp)\n    additionalCmds, err := g.discoverAdditionalCommands()\n    if err != nil {\n        // Log warning but continue with core commands\n        log.Warnf(\"Failed to discover additional commands: %v\", err)\n    } else {\n        commands = append(commands, additionalCmds...)\n    }\n\n    var generatedPaths []string\n\n    for _, cmd := range commands {\n        // Generate .exe shim (primary for PATH resolution)\n        exePath, err := g.generateShimFile(cmd, \".exe\")\n        if err != nil {\n            return nil, fmt.Errorf(\"generate %s.exe: %w\", cmd, err)\n        }\n        generatedPaths = append(generatedPaths, exePath)\n\n        // Generate .cmd shim (compatibility for cmd.exe)\n        cmdPath, err := g.generateBatchShim(cmd)\n        if err != nil {\n            return nil, fmt.Errorf(\"generate %s.cmd: %w\", cmd, err)\n        }\n        generatedPaths = append(generatedPaths, cmdPath)\n    }\n\n    return generatedPaths, nil\n}\n\n// generateShimFile creates executable shim by copying shim.exe\nfunc (g *ShimGenerator) generateShimFile(command string, ext string) (string, error) {\n    destPath := filepath.Join(g.shimsDir, command+ext)\n\n    // Copy shim.exe to destination with new name\n    // This allows filename-based command detection\n    if err := copyFile(g.shimBinary, destPath); err != nil {\n        return \"\", fmt.Errorf(\"copy shim binary: %w\", err)\n    }\n\n    // Verify executable\n    if err := verifyExecutable(destPath); err != nil {\n        return \"\", fmt.Errorf(\"verify executable: %w\", err)\n    }\n\n    return destPath, nil\n}\n\n// generateBatchShim creates .cmd shim that calls .exe shim\nfunc (g *ShimGenerator) generateBatchShim(command string) (string, error) {\n    destPath := filepath.Join(g.shimsDir, command+\".cmd\")\n\n    // Batch script that forwards to .exe shim\n    script := fmt.Sprintf(`@echo off\n\"%~dp0%s.exe\" %%*\nexit /b %%ERRORLEVEL%%\n`, command)\n\n    if err := os.WriteFile(destPath, []byte(script), 0755); err != nil {\n        return \"\", fmt.Errorf(\"write batch shim: %w\", err)\n    }\n\n    return destPath, nil\n}\n\n// discoverAdditionalCommands scans installed versions for commands like mvnyjp\nfunc (g *ShimGenerator) discoverAdditionalCommands() ([]string, error) {\n    var additionalCmds []string\n\n    entries, err := os.ReadDir(g.versionsDir)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil, nil // No versions installed yet\n        }\n        return nil, err\n    }\n\n    cmdSet := make(map[string]bool)\n\n    for _, entry := range entries {\n        if !entry.IsDir() {\n            continue\n        }\n\n        binDir := filepath.Join(g.versionsDir, entry.Name(), \"bin\")\n        binEntries, err := os.ReadDir(binDir)\n        if err != nil {\n            continue\n        }\n\n        for _, binEntry := range binEntries {\n            name := binEntry.Name()\n            // Look for .cmd files that aren't mvn or mvnDebug\n            if strings.HasSuffix(name, \".cmd\") {\n                cmd := strings.TrimSuffix(name, \".cmd\")\n                if cmd != \"mvn\" && cmd != \"mvnDebug\" && !cmdSet[cmd] {\n                    cmdSet[cmd] = true\n                    additionalCmds = append(additionalCmds, cmd)\n                }\n            }\n        }\n    }\n\n    return additionalCmds, nil\n}\n\n// copyFile copies file from src to dst atomically\nfunc copyFile(src, dst string) error {\n    source, err := os.Open(src)\n    if err != nil {\n        return err\n    }\n    defer source.Close()\n\n    // Write to temp file first\n    tmpDst := dst + \".tmp\"\n    destination, err := os.Create(tmpDst)\n    if err != nil {\n        return err\n    }\n\n    _, err = io.Copy(destination, source)\n    destination.Close()\n    if err != nil {\n        os.Remove(tmpDst)\n        return err\n    }\n\n    // Atomic rename\n    if err := os.Rename(tmpDst, dst); err != nil {\n        os.Remove(tmpDst)\n        return err\n    }\n\n    return nil\n}\n\n// verifyExecutable checks if file is executable\nfunc verifyExecutable(path string) error {\n    info, err := os.Stat(path)\n    if err != nil {\n        return err\n    }\n\n    if info.IsDir() {\n        return fmt.Errorf(\"path is directory\")\n    }\n\n    // On Windows, check .exe extension\n    if !strings.HasSuffix(path, \".exe\") && !strings.HasSuffix(path, \".cmd\") {\n        return fmt.Errorf(\"not an executable file\")\n    }\n\n    return nil\n}\n```\n\n**Key Design Decisions:**\n- Copy shim.exe approach: allows single binary to serve multiple commands\n- Atomic file operations: temp file + rename prevents partial shims\n- .exe + .cmd generation: ensures compatibility across Windows shells\n- Additional command discovery: automatically includes mvnyjp if available\n- Error handling: continues on non-critical errors (e.g., discovery failure)\n\n### 3. ShimExecutor\n\nHandles command execution with version resolution and I/O forwarding.\n\n```go\n// internal/shim/executor.go\npackage shim\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"os/exec\"\n    \"os/signal\"\n    \"path/filepath\"\n    \"syscall\"\n    \"time\"\n\n    \"github.com/veenone/mvnenv-win/internal/version\"\n)\n\n// ShimExecutor executes Maven commands with version resolution\ntype ShimExecutor struct {\n    resolver *version.VersionResolver\n    debug    bool // Enable debug output\n}\n\n// NewShimExecutor creates a shim executor\nfunc NewShimExecutor(resolver *version.VersionResolver) *ShimExecutor {\n    debug := os.Getenv(\"MVNENV_DEBUG\") == \"1\"\n    return &ShimExecutor{\n        resolver: resolver,\n        debug:    debug,\n    }\n}\n\n// Execute resolves Maven version and executes command\n// Returns Maven's exit code and any resolution errors\nfunc (e *ShimExecutor) Execute(command string, args []string) (int, error) {\n    startTime := time.Now()\n\n    // Resolve active Maven version\n    resolved, err := e.resolver.ResolveVersion()\n    if err != nil {\n        return 1, e.formatResolutionError(err)\n    }\n\n    resolutionTime := time.Since(startTime)\n\n    // Construct path to Maven command\n    mavenPath := e.constructMavenPath(resolved.Path, command)\n\n    // Verify Maven binary exists\n    if _, err := os.Stat(mavenPath); err != nil {\n        return 1, fmt.Errorf(\"Maven binary not found at %s\\nVersion %s may be corrupted. Try reinstalling with: mvnenv install %s\",\n            mavenPath, resolved.Version, resolved.Version)\n    }\n\n    if e.debug {\n        e.logDebug(command, args, resolved, mavenPath, resolutionTime)\n    }\n\n    // Execute Maven with I/O forwarding\n    exitCode, err := e.executeMaven(mavenPath, args, resolved)\n\n    if e.debug {\n        executionTime := time.Since(startTime)\n        fmt.Fprintf(os.Stderr, \"[mvnenv] Total execution time: %v\\n\", executionTime)\n    }\n\n    return exitCode, err\n}\n\n// constructMavenPath builds path to Maven command binary\nfunc (e *ShimExecutor) constructMavenPath(versionPath string, command string) string {\n    // versionPath: %USERPROFILE%\\.mvnenv\\versions\\3.9.4\n    // Result: %USERPROFILE%\\.mvnenv\\versions\\3.9.4\\bin\\mvn.cmd\n    return filepath.Join(versionPath, \"bin\", command+\".cmd\")\n}\n\n// executeMaven spawns Maven process with I/O forwarding\nfunc (e *ShimExecutor) executeMaven(mavenPath string, args []string, resolved *version.ResolvedVersion) (int, error) {\n    // Create command with context for cancellation\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n\n    cmd := exec.CommandContext(ctx, mavenPath, args...)\n\n    // Set MAVEN_HOME environment variable\n    cmd.Env = append(os.Environ(), fmt.Sprintf(\"MAVEN_HOME=%s\", resolved.Path))\n\n    // Forward stdin/stdout/stderr (no buffering)\n    cmd.Stdin = os.Stdin\n    cmd.Stdout = os.Stdout\n    cmd.Stderr = os.Stderr\n\n    // Set working directory to current directory\n    cmd.Dir, _ = os.Getwd()\n\n    // Handle signals (Ctrl+C, etc.)\n    signalChan := make(chan os.Signal, 1)\n    signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM)\n    go func() {\n        <-signalChan\n        cancel() // Cancel context, which kills Maven process\n    }()\n\n    // Start Maven process\n    if err := cmd.Start(); err != nil {\n        return 1, fmt.Errorf(\"failed to start Maven: %w\", err)\n    }\n\n    // Wait for Maven to complete\n    if err := cmd.Wait(); err != nil {\n        // Extract exit code from error\n        if exitErr, ok := err.(*exec.ExitError); ok {\n            if status, ok := exitErr.Sys().(syscall.WaitStatus); ok {\n                return status.ExitStatus(), nil\n            }\n        }\n        // Unknown error, return 1\n        return 1, err\n    }\n\n    return 0, nil\n}\n\n// formatResolutionError creates user-friendly error messages\nfunc (e *ShimExecutor) formatResolutionError(err error) error {\n    switch {\n    case version.IsVersionNotInstalledError(err):\n        v := version.ExtractVersionFromError(err)\n        return fmt.Errorf(\"Maven version '%s' is set but not installed.\\nInstall it with: mvnenv install %s\", v, v)\n\n    case version.IsNoVersionSetError(err):\n        return fmt.Errorf(\"No Maven version is set.\\nSet a global version with: mvnenv global <version>\\nOr see available versions with: mvnenv install -l\")\n\n    default:\n        return fmt.Errorf(\"Failed to resolve Maven version: %w\", err)\n    }\n}\n\n// logDebug outputs diagnostic information to stderr\nfunc (e *ShimExecutor) logDebug(command string, args []string, resolved *version.ResolvedVersion, mavenPath string, resolutionTime time.Duration) {\n    fmt.Fprintf(os.Stderr, \"[mvnenv] Debug Information:\\n\")\n    fmt.Fprintf(os.Stderr, \"[mvnenv]   Command: %s\\n\", command)\n    fmt.Fprintf(os.Stderr, \"[mvnenv]   Arguments: %v\\n\", args)\n    fmt.Fprintf(os.Stderr, \"[mvnenv]   Resolved version: %s\\n\", resolved.Version)\n    fmt.Fprintf(os.Stderr, \"[mvnenv]   Source: %s\\n\", resolved.Source)\n    fmt.Fprintf(os.Stderr, \"[mvnenv]   Maven path: %s\\n\", mavenPath)\n    fmt.Fprintf(os.Stderr, \"[mvnenv]   MAVEN_HOME: %s\\n\", resolved.Path)\n    fmt.Fprintf(os.Stderr, \"[mvnenv]   Resolution time: %v\\n\", resolutionTime)\n}\n```\n\n**Key Design Decisions:**\n- Context-based cancellation: proper signal handling\n- Direct I/O forwarding: cmd.Stdin/Stdout/Stderr = os.Stdin/Stdout/Stderr\n- Exit code extraction: preserves Maven's exact exit code\n- MAVEN_HOME injection: set only for Maven subprocess\n- Debug mode: controlled via MVNENV_DEBUG environment variable\n- Error formatting: converts internal errors to user-friendly messages\n\n### 4. Version Resolution Integration\n\nIntegration with VersionResolver from core-version-management spec.\n\n```go\n// internal/shim/resolver.go\npackage shim\n\nimport (\n    \"github.com/veenone/mvnenv-win/internal/version\"\n)\n\n// ResolveActiveVersion is a convenience wrapper around VersionResolver\n// Used by ShimExecutor\nfunc ResolveActiveVersion(mvnenvRoot string) (*version.ResolvedVersion, error) {\n    resolver := version.NewVersionResolver(mvnenvRoot)\n    return resolver.ResolveVersion()\n}\n```\n\n**Integration Points:**\n1. Shim calls `version.VersionResolver.ResolveVersion()`\n2. VersionResolver follows shell > local > global hierarchy\n3. Returns `ResolvedVersion` with version string, path, and source\n4. Shim uses path to construct Maven binary location\n\n### 5. PATH Management (Windows-specific)\n\n```go\n// internal/shim/path_windows.go\n//go:build windows\n\npackage shim\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"golang.org/x/sys/windows/registry\"\n)\n\n// PathManager manages Windows PATH environment variable\ntype PathManager struct {\n    shimsDir string\n}\n\n// NewPathManager creates a PATH manager\nfunc NewPathManager(mvnenvRoot string) *PathManager {\n    return &PathManager{\n        shimsDir: filepath.Join(mvnenvRoot, \"shims\"),\n    }\n}\n\n// AddShimsDirToPath adds shims directory to user PATH\n// Returns true if PATH was modified, false if already present\nfunc (m *PathManager) AddShimsDirToPath() (bool, error) {\n    // Open user environment key\n    key, err := registry.OpenKey(registry.CURRENT_USER, `Environment`, registry.QUERY_VALUE|registry.SET_VALUE)\n    if err != nil {\n        return false, fmt.Errorf(\"open registry key: %w\", err)\n    }\n    defer key.Close()\n\n    // Read current PATH\n    currentPath, _, err := key.GetStringValue(\"Path\")\n    if err != nil && err != registry.ErrNotExist {\n        return false, fmt.Errorf(\"read PATH: %w\", err)\n    }\n\n    // Check if shims directory already in PATH (case-insensitive)\n    if m.isInPath(currentPath, m.shimsDir) {\n        return false, nil // Already present\n    }\n\n    // Prepend shims directory to PATH\n    var newPath string\n    if currentPath == \"\" {\n        newPath = m.shimsDir\n    } else {\n        newPath = m.shimsDir + \";\" + currentPath\n    }\n\n    // Write new PATH to registry\n    if err := key.SetStringValue(\"Path\", newPath); err != nil {\n        return false, fmt.Errorf(\"write PATH: %w\", err)\n    }\n\n    // Broadcast environment change to Windows\n    m.broadcastEnvironmentChange()\n\n    return true, nil\n}\n\n// isInPath checks if directory is in PATH (case-insensitive)\nfunc (m *PathManager) isInPath(path string, dir string) bool {\n    paths := strings.Split(path, \";\")\n    dirLower := strings.ToLower(dir)\n\n    for _, p := range paths {\n        if strings.ToLower(strings.TrimSpace(p)) == dirLower {\n            return true\n        }\n    }\n\n    return false\n}\n\n// broadcastEnvironmentChange notifies Windows of environment change\nfunc (m *PathManager) broadcastEnvironmentChange() {\n    // Use SendMessageTimeout to broadcast WM_SETTINGCHANGE\n    // This makes the change visible to new processes without logout\n    // Implementation uses syscall to SendMessageTimeoutW\n}\n\n// RemoveShimsDirFromPath removes shims directory from user PATH\nfunc (m *PathManager) RemoveShimsDirFromPath() (bool, error) {\n    key, err := registry.OpenKey(registry.CURRENT_USER, `Environment`, registry.QUERY_VALUE|registry.SET_VALUE)\n    if err != nil {\n        return false, fmt.Errorf(\"open registry key: %w\", err)\n    }\n    defer key.Close()\n\n    currentPath, _, err := key.GetStringValue(\"Path\")\n    if err != nil {\n        return false, fmt.Errorf(\"read PATH: %w\", err)\n    }\n\n    // Remove shims directory from PATH\n    newPath := m.removeFromPath(currentPath, m.shimsDir)\n\n    if newPath == currentPath {\n        return false, nil // Not present\n    }\n\n    if err := key.SetStringValue(\"Path\", newPath); err != nil {\n        return false, fmt.Errorf(\"write PATH: %w\", err)\n    }\n\n    m.broadcastEnvironmentChange()\n\n    return true, nil\n}\n\n// removeFromPath removes directory from PATH string\nfunc (m *PathManager) removeFromPath(path string, dir string) string {\n    paths := strings.Split(path, \";\")\n    dirLower := strings.ToLower(dir)\n\n    var newPaths []string\n    for _, p := range paths {\n        trimmed := strings.TrimSpace(p)\n        if trimmed != \"\" && strings.ToLower(trimmed) != dirLower {\n            newPaths = append(newPaths, trimmed)\n        }\n    }\n\n    return strings.Join(newPaths, \";\")\n}\n```\n\n**Key Design Decisions:**\n- Registry-based PATH management: modifies HKCU\\Environment\n- Case-insensitive comparison: Windows paths are case-insensitive\n- Prepend to PATH: ensures shims take priority\n- Broadcast change: SendMessageTimeout makes change visible immediately\n- User-level only: no system-wide PATH modification\n\n## Error Handling\n\n### Error Types and Messages\n\n```go\n// Common shim errors\nvar (\n    ErrShimBinaryNotFound = errors.New(\"shim binary not found\")\n    ErrVersionNotResolved = errors.New(\"version resolution failed\")\n    ErrMavenBinaryNotFound = errors.New(\"Maven binary not found\")\n    ErrExecutionFailed = errors.New(\"Maven execution failed\")\n)\n\n// ShimError wraps errors with shim context\ntype ShimError struct {\n    Command string\n    Step    string // \"resolution\", \"execution\", \"generation\"\n    Cause   error\n}\n\nfunc (e *ShimError) Error() string {\n    return fmt.Sprintf(\"mvnenv shim error in %s for command '%s': %v\", e.Step, e.Command, e.Cause)\n}\n```\n\n### Error Handling Strategy\n\n1. **Resolution Errors**: Clear message with suggested action (install version, set global)\n2. **Execution Errors**: Preserve Maven's error output, add shim context only if Maven didn't start\n3. **Generation Errors**: Detailed error with which step failed\n4. **PATH Errors**: Provide manual instructions if automatic modification fails\n\n## Performance Optimization\n\n### Optimization Techniques\n\n1. **Fast Version Resolution**:\n   - Read only necessary files (.maven-version, config.yaml)\n   - No network operations\n   - No expensive parsing\n\n2. **Direct Process Execution**:\n   - Use exec.CommandContext for minimal overhead\n   - No intermediate shells or scripts\n   - Direct I/O forwarding (no buffering)\n\n3. **Lazy Loading**:\n   - Don't load configuration unless needed\n   - Don't discover additional commands during execution\n\n4. **Binary Copying for Shim Generation**:\n   - Copying shim.exe is faster than generating scripts\n   - Enables filename-based command detection\n\n### Performance Benchmarks\n\nTarget performance metrics:\n- Version resolution: <25ms\n- Process spawn: <25ms\n- Total overhead: <50ms\n\nMeasurement approach:\n```go\nfunc BenchmarkShimOverhead(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        start := time.Now()\n        // Resolve version\n        // Spawn process (no-op Maven for test)\n        overhead := time.Since(start)\n        if overhead > 50*time.Millisecond {\n            b.Fatalf(\"Overhead too high: %v\", overhead)\n        }\n    }\n}\n```\n\n## Integration Points\n\n### Integration with core-version-management\n\n```go\n// ShimExecutor uses VersionResolver\ntype ShimExecutor struct {\n    resolver *version.VersionResolver\n}\n\nfunc (e *ShimExecutor) Execute(command string, args []string) (int, error) {\n    // Call VersionResolver from core-version-management\n    resolved, err := e.resolver.ResolveVersion()\n    if err != nil {\n        return 1, e.formatResolutionError(err)\n    }\n\n    // Use resolved.Path to construct Maven binary path\n    mavenPath := filepath.Join(resolved.Path, \"bin\", command+\".cmd\")\n\n    // Execute Maven with MAVEN_HOME set to resolved.Path\n    return e.executeMaven(mavenPath, args, resolved)\n}\n```\n\n### Integration with cli-commands\n\n```go\n// cmd/mvnenv/cmd/rehash.go\nfunc runRehash(cmd *cobra.Command, args []string) error {\n    generator := shim.NewShimGenerator(mvnenvRoot)\n\n    generatedPaths, err := generator.GenerateShims()\n    if err != nil {\n        return fmt.Errorf(\"failed to regenerate shims: %w\", err)\n    }\n\n    fmt.Printf(\"Shims regenerated successfully (%d files)\\n\", len(generatedPaths))\n    return nil\n}\n```\n\n### Automatic Regeneration Hooks\n\n```go\n// In internal/version/installer.go\nfunc (i *VersionInstaller) InstallVersion(version string) error {\n    // ... installation logic ...\n\n    // Automatically regenerate shims after installation\n    if err := i.regenerateShims(); err != nil {\n        log.Warnf(\"Failed to regenerate shims: %v\", err)\n        log.Info(\"Run 'mvnenv rehash' manually to update shims\")\n    }\n\n    return nil\n}\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n```go\n// internal/shim/generator_test.go\nfunc TestShimGenerator_GenerateShims(t *testing.T)\nfunc TestShimGenerator_DiscoverAdditionalCommands(t *testing.T)\nfunc TestShimGenerator_AtomicGeneration(t *testing.T)\n\n// internal/shim/executor_test.go\nfunc TestShimExecutor_Execute_Success(t *testing.T)\nfunc TestShimExecutor_Execute_VersionNotFound(t *testing.T)\nfunc TestShimExecutor_Execute_ExitCodePreserved(t *testing.T)\nfunc TestShimExecutor_Execute_SignalHandling(t *testing.T)\n\n// internal/shim/path_windows_test.go\nfunc TestPathManager_AddShimsDirToPath(t *testing.T)\nfunc TestPathManager_IsInPath_CaseInsensitive(t *testing.T)\nfunc TestPathManager_RemoveShimsDirFromPath(t *testing.T)\n```\n\n### Integration Tests\n\n```go\n// test/integration/shim_integration_test.go\n\n// Test full workflow: generate shim, invoke, verify Maven executed\nfunc TestIntegration_ShimExecution(t *testing.T)\n\n// Test shim with different version sources (shell, local, global)\nfunc TestIntegration_ShimVersionResolution(t *testing.T)\n\n// Test I/O forwarding (stdin, stdout, stderr)\nfunc TestIntegration_ShimIOForwarding(t *testing.T)\n\n// Test exit code preservation\nfunc TestIntegration_ShimExitCode(t *testing.T)\n\n// Test concurrent shim invocations\nfunc TestIntegration_ConcurrentShims(t *testing.T)\n```\n\n### Performance Tests\n\n```go\n// test/benchmarks/shim_bench_test.go\n\n// Measure shim overhead\nfunc BenchmarkShimOverhead(b *testing.B)\n\n// Measure version resolution time\nfunc BenchmarkVersionResolution(b *testing.B)\n\n// Measure process spawn time\nfunc BenchmarkProcessSpawn(b *testing.B)\n```\n\n## Security Considerations\n\n### Path Injection Prevention\n\n```go\n// Validate resolved Maven path before execution\nfunc (e *ShimExecutor) validateMavenPath(path string, versionPath string) error {\n    // Ensure path is within version directory\n    absPath, err := filepath.Abs(path)\n    if err != nil {\n        return err\n    }\n\n    absVersionPath, err := filepath.Abs(versionPath)\n    if err != nil {\n        return err\n    }\n\n    // Check path is within version directory\n    if !strings.HasPrefix(absPath, absVersionPath) {\n        return fmt.Errorf(\"Maven path outside version directory: %s\", absPath)\n    }\n\n    return nil\n}\n```\n\n### Argument Safety\n\n- Arguments passed unchanged to Maven (no interpretation)\n- No shell expansion or command substitution\n- Direct process execution (not via shell)\n\n### Environment Isolation\n\n- MAVEN_HOME only set for Maven subprocess\n- Parent shell environment unaffected\n- No persistent environment changes\n\n## Configuration\n\n### Debug Mode\n\nEnable via environment variable:\n```bash\nset MVNENV_DEBUG=1\nmvn clean\n```\n\nDebug output (to stderr):\n```\n[mvnenv] Debug Information:\n[mvnenv]   Command: mvn\n[mvnenv]   Arguments: [clean]\n[mvnenv]   Resolved version: 3.9.4\n[mvnenv]   Source: local (.maven-version)\n[mvnenv]   Maven path: C:\\Users\\user\\.mvnenv\\versions\\3.9.4\\bin\\mvn.cmd\n[mvnenv]   MAVEN_HOME: C:\\Users\\user\\.mvnenv\\versions\\3.9.4\n[mvnenv]   Resolution time: 12ms\n[mvnenv] Total execution time: 2.345s\n```\n\n## Future Enhancements\n\n### Phase 1 (v1.1.0)\n- Maven wrapper (mvnw) detection and preference\n- Custom shim hooks for pre/post execution\n- Performance telemetry (opt-in)\n\n### Phase 2 (v1.2.0)\n- IDE integration hints (environment file generation)\n- Shim auto-update on mvnenv upgrade\n- Plugin system for custom shim behavior\n\n### Phase 3 (v2.0.0)\n- Cross-platform shim support (Linux, macOS)\n- Remote execution support (SSH forwarding)\n- Container-aware shim behavior\n",
  "fileStats": {
    "size": 26964,
    "lines": 919,
    "lastModified": "2025-10-12T07:21:18.639Z"
  },
  "comments": []
}