{
  "id": "snapshot_1760234510820_k1dldjghy",
  "approvalId": "approval_1760234510746_aqwdu35nl",
  "approvalTitle": "CLI Commands - Design Document",
  "version": 1,
  "timestamp": "2025-10-12T02:01:50.820Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe CLI Commands feature implements the foundational command-line interface framework for mvnenv-win using the Cobra library. This design establishes a modular, extensible command structure that mirrors pyenv-win's proven UX while providing the infrastructure for all other mvnenv-win features to build upon.\n\nThe framework handles command registration, parsing, help generation, error handling, and output formatting. Business logic for specific commands (version management, repository configuration, shim operations) resides in separate internal packages and will be implemented in other specs.\n\n**Key Design Principles:**\n- Cobra-based command structure for robust CLI handling\n- Each command is a separate file for modularity\n- Plain text output matching pyenv-win conventions (no colors, emojis, or decorative elements)\n- Minimal output: setter commands silent on success\n- Fast execution through lazy loading and minimal initialization\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Language and Framework:**\n- **Go 1.21+**: Implementation language per tech.md\n- **github.com/spf13/cobra v1.8+**: CLI framework as specified in tech.md dependencies\n- **Command Pattern**: Each command as discrete module per tech.md architecture\n\n**Architecture Alignment:**\n- **Modular Command-Line Architecture**: Follows tech.md's command pattern design\n- **Configuration Singleton**: Uses Viper for centralized config per tech.md\n- **Performance Requirements**: <50ms startup, <100ms help generation per tech.md\n\n**Dependency Usage:**\n- **cobra**: Command structure, parsing, help generation\n- **viper**: Configuration management (loaded lazily)\n- **os**: Standard library for stdout/stderr, exit codes\n\n### Project Structure (structure.md)\n\n**Directory Organization:**\n```\ncmd/mvnenv/               # Main CLI entry point per structure.md\n├── main.go              # Application entry point, Cobra root setup\n├── commands.go          # \"commands\" command implementation\n├── version.go           # \"version\" command implementation\n├── versions.go          # \"versions\" command implementation\n├── global.go            # \"global\" command implementation\n├── local.go             # \"local\" command implementation\n├── shell.go             # \"shell\" command implementation\n├── install.go           # \"install\" command implementation\n├── uninstall.go         # \"uninstall\" command implementation\n├── update.go            # \"update\" command implementation\n├── rehash.go            # \"rehash\" command implementation\n├── which.go             # \"which\" command implementation\n├── latest.go            # \"latest\" command implementation\n└── help.go              # \"help\" command (Cobra built-in wrapped)\n```\n\n**Naming Conventions:**\n- Files: `snake_case.go` per structure.md\n- Exported functions: `PascalCase`\n- Unexported functions: `camelCase`\n- Command constructors: `NewVersionCmd()`, `NewInstallCmd()`, etc.\n\n**Code Organization Pattern (per structure.md):**\n1. Package declaration and documentation\n2. Imports (stdlib, third-party, internal)\n3. Command constructor function\n4. Command run function\n5. Helper functions (unexported)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**None - This is Foundation Code**\n\nThis spec implements the CLI framework foundation. Future specs will leverage this infrastructure:\n\n- **core-version-management**: Will register install/uninstall/versions commands using this framework\n- **nexus-repository-integration**: Will add repo-related commands using this structure\n- **shim-system-implementation**: Will implement rehash/which commands leveraging this foundation\n\n### Integration Points for Future Specs\n\n**Command Registration Pattern:**\nOther specs will add commands by creating command files in `cmd/mvnenv/` that follow this pattern:\n\n```go\n// NewInstallCmd creates the install command\n// (Implementation in core-version-management spec)\nfunc NewInstallCmd() *cobra.Command {\n    cmd := &cobra.Command{\n        Use:   \"install [version...]\",\n        Short: \"Install one or more Maven versions\",\n        RunE:  runInstall,\n    }\n    cmd.Flags().BoolP(\"list\", \"l\", false, \"List available versions\")\n    cmd.Flags().BoolP(\"quiet\", \"q\", false, \"Suppress non-error output\")\n    return cmd\n}\n```\n\n**Internal Package Dependencies:**\nCommands will call internal packages for business logic:\n- `internal/version`: Version management operations\n- `internal/config`: Configuration access\n- `internal/environment`: PATH and environment manipulation\n- `internal/shim`: Shim generation and management\n\n## Architecture\n\n### Overall Design Pattern\n\n**Cobra Command Tree Architecture:**\n\n```\nmvnenv (root)\n├── commands         # List all commands\n├── version          # Show current Maven version\n├── versions         # List installed versions\n├── global [ver]     # Set/show global version\n├── local [ver]      # Set/show local version\n├── shell [ver]      # Set/show shell version\n├── install [ver...] # Install Maven version(s)\n│   └── flags: -l (list), -q (quiet)\n├── uninstall [ver...] # Uninstall version(s)\n├── update           # Update version cache\n├── rehash           # Rebuild shims\n├── which <cmd>      # Show command path\n├── latest [prefix]  # Show latest version\n└── help [cmd]       # Show help\n```\n\n### Modular Design Principles\n\n**Single File Responsibility:**\nEach command in a separate file (`version.go`, `install.go`, etc.) containing:\n- Command constructor\n- Command execution logic\n- Command-specific helpers\n\n**Component Isolation:**\n- Root command setup in `main.go`\n- Each subcommand in its own file\n- Shared utilities in separate helper files\n\n**Service Layer Separation:**\n- CLI layer (`cmd/mvnenv/`): Command parsing, flag handling, output formatting\n- Business logic layer (`internal/`): Version management, config, operations\n- This spec implements CLI layer only\n\n### Command Registration Flow\n\n```mermaid\ngraph TD\n    A[main.go] --> B[Create Root Command]\n    B --> C[Register Global Flags]\n    C --> D[Add Subcommands]\n    D --> E[version.go: NewVersionCmd]\n    D --> F[versions.go: NewVersionsCmd]\n    D --> G[global.go: NewGlobalCmd]\n    D --> H[install.go: NewInstallCmd]\n    D --> I[... other commands]\n    E --> J[rootCmd.AddCommand]\n    F --> J\n    G --> J\n    H --> J\n    I --> J\n    J --> K[rootCmd.Execute]\n    K --> L[Cobra parses args]\n    L --> M[Executes matched command]\n```\n\n### Command Execution Flow\n\n```mermaid\ngraph TD\n    A[User types: mvnenv global 3.9.4] --> B[main.go: rootCmd.Execute]\n    B --> C[Cobra parses command and args]\n    C --> D[Matches 'global' command]\n    D --> E[Calls global.go: runGlobal]\n    E --> F{Validate arguments}\n    F -->|Invalid| G[Print error to stderr]\n    F -->|Valid| H[Call internal/version package]\n    G --> I[Exit with code 1]\n    H --> J{Operation successful?}\n    J -->|No| K[Print error to stderr]\n    J -->|Yes| L[Print output to stdout if any]\n    K --> M[Exit with code 1]\n    L --> N[Exit with code 0]\n```\n\n## Components and Interfaces\n\n### Component 1: Root Command (main.go)\n\n**Purpose:** Initialize Cobra root command, register all subcommands, handle global flags and execution\n\n**Interfaces:**\n```go\n// main function - entry point\nfunc main()\n\n// initRootCmd initializes the root cobra command\nfunc initRootCmd() *cobra.Command\n\n// Execute runs the root command\nfunc Execute() error\n```\n\n**Implementation:**\n```go\nvar rootCmd = &cobra.Command{\n    Use:   \"mvnenv\",\n    Short: \"Maven version manager for Windows\",\n    Long:  `mvnenv manages multiple Maven installations...`,\n    SilenceErrors: true, // We handle errors ourselves\n    SilenceUsage:  true, // Don't show usage on every error\n}\n\nfunc init() {\n    // Register global flags\n    rootCmd.PersistentFlags().BoolP(\"quiet\", \"q\", false, \"Suppress non-error output\")\n\n    // Add all subcommands\n    rootCmd.AddCommand(NewCommandsCmd())\n    rootCmd.AddCommand(NewVersionCmd())\n    rootCmd.AddCommand(NewVersionsCmd())\n    rootCmd.AddCommand(NewGlobalCmd())\n    rootCmd.AddCommand(NewLocalCmd())\n    rootCmd.AddCommand(NewShellCmd())\n    rootCmd.AddCommand(NewInstallCmd())\n    rootCmd.AddCommand(NewUninstallCmd())\n    rootCmd.AddCommand(NewUpdateCmd())\n    rootCmd.AddCommand(NewRehashCmd())\n    rootCmd.AddCommand(NewWhichCmd())\n    rootCmd.AddCommand(NewLatestCmd())\n}\n\nfunc main() {\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Fprintln(os.Stderr, err)\n        os.Exit(1)\n    }\n}\n```\n\n**Dependencies:**\n- `github.com/spf13/cobra`\n- All command constructors (NewVersionCmd, NewInstallCmd, etc.)\n\n### Component 2: Commands Command (commands.go)\n\n**Purpose:** List all available commands (pyenv-win compatibility)\n\n**Interfaces:**\n```go\n// NewCommandsCmd creates the commands command\nfunc NewCommandsCmd() *cobra.Command\n\n// runCommands executes the commands command\nfunc runCommands(cmd *cobra.Command, args []string) error\n```\n\n**Implementation:**\n```go\nfunc NewCommandsCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"commands\",\n        Short: \"List all available mvnenv commands\",\n        RunE:  runCommands,\n    }\n}\n\nfunc runCommands(cmd *cobra.Command, args []string) error {\n    // Get all commands from root\n    commands := cmd.Root().Commands()\n    for _, c := range commands {\n        if !c.Hidden {\n            fmt.Println(c.Name())\n        }\n    }\n    return nil\n}\n```\n\n**Dependencies:**\n- `fmt`, `os`\n- Cobra command tree\n\n### Component 3: Version Command (version.go)\n\n**Purpose:** Display currently active Maven version\n\n**Interfaces:**\n```go\n// NewVersionCmd creates the version command\nfunc NewVersionCmd() *cobra.Command\n\n// runVersion executes the version command\nfunc runVersion(cmd *cobra.Command, args []string) error\n```\n\n**Implementation:**\n```go\nfunc NewVersionCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"version\",\n        Short: \"Show the current Maven version\",\n        RunE:  runVersion,\n    }\n}\n\nfunc runVersion(cmd *cobra.Command, args []string) error {\n    // Business logic in internal/version package (other spec)\n    // This spec defines the command structure only\n\n    // Pseudocode for future implementation:\n    // resolver := version.NewResolver()\n    // ver, err := resolver.GetCurrentVersion()\n    // if err != nil {\n    //     return fmt.Errorf(\"Error: %w\", err)\n    // }\n    // if ver == \"\" {\n    //     fmt.Println(\"No Maven version set\")\n    //     return nil\n    // }\n    // fmt.Println(ver)\n    // return nil\n\n    // For this spec (CLI framework only):\n    fmt.Println(\"3.9.4\") // Placeholder\n    return nil\n}\n```\n\n**Dependencies:**\n- `fmt`, `os`\n- `internal/version` (implementation in other spec)\n\n### Component 4: Versions Command (versions.go)\n\n**Purpose:** List all installed Maven versions, marking current with `*`\n\n**Interfaces:**\n```go\n// NewVersionsCmd creates the versions command\nfunc NewVersionsCmd() *cobra.Command\n\n// runVersions executes the versions command\nfunc runVersions(cmd *cobra.Command, args []string) error\n```\n\n**Implementation:**\n```go\nfunc NewVersionsCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"versions\",\n        Short: \"List all installed Maven versions\",\n        RunE:  runVersions,\n    }\n}\n\nfunc runVersions(cmd *cobra.Command, args []string) error {\n    // Business logic in internal/version package\n    // Pseudocode:\n    // manager := version.NewManager()\n    // versions, err := manager.ListInstalled()\n    // current, _ := resolver.GetCurrentVersion()\n    // for _, v := range versions {\n    //     if v == current {\n    //         fmt.Printf(\"* %s\\n\", v)\n    //     } else {\n    //         fmt.Printf(\"  %s\\n\", v)\n    //     }\n    // }\n\n    // Placeholder for CLI framework spec:\n    fmt.Println(\"* 3.9.4\")\n    fmt.Println(\"  3.8.6\")\n    return nil\n}\n```\n\n**Dependencies:**\n- `fmt`, `os`\n- `internal/version` (implementation in other spec)\n\n### Component 5: Global/Local/Shell Commands\n\n**Purpose:** Set or show Maven version at different scopes\n\n**Interfaces:**\n```go\n// NewGlobalCmd creates the global command\nfunc NewGlobalCmd() *cobra.Command\n\n// NewLocalCmd creates the local command\nfunc NewLocalCmd() *cobra.Command\n\n// NewShellCmd creates the shell command\nfunc NewShellCmd() *cobra.Command\n\n// runGlobal executes the global command\nfunc runGlobal(cmd *cobra.Command, args []string) error\n\n// runLocal executes the local command\nfunc runLocal(cmd *cobra.Command, args []string) error\n\n// runShell executes the shell command\nfunc runShell(cmd *cobra.Command, args []string) error\n```\n\n**Implementation Pattern (global.go example):**\n```go\nfunc NewGlobalCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"global [version]\",\n        Short: \"Set or show the global Maven version\",\n        Args:  cobra.MaximumNArgs(1),\n        RunE:  runGlobal,\n    }\n}\n\nfunc runGlobal(cmd *cobra.Command, args []string) error {\n    if len(args) == 0 {\n        // Show current global version\n        // Call internal/version.GetGlobalVersion()\n        fmt.Println(\"3.9.4\") // Placeholder\n        return nil\n    }\n\n    // Set global version\n    version := args[0]\n    // Call internal/version.SetGlobalVersion(version)\n\n    // On success, output nothing (pyenv-win convention)\n    return nil\n}\n```\n\n**Shell Command Special Handling:**\n```go\nfunc NewShellCmd() *cobra.Command {\n    cmd := &cobra.Command{\n        Use:   \"shell [version]\",\n        Short: \"Set or show the shell-specific Maven version\",\n        RunE:  runShell,\n    }\n    cmd.Flags().Bool(\"unset\", false, \"Unset shell version\")\n    return cmd\n}\n\nfunc runShell(cmd *cobra.Command, args []string) error {\n    unset, _ := cmd.Flags().GetBool(\"unset\")\n\n    if unset {\n        // Unset shell version\n        // Call internal/version.UnsetShellVersion()\n        return nil\n    }\n\n    if len(args) == 0 {\n        // Show current shell version\n        // Call internal/version.GetShellVersion()\n        fmt.Println(\"3.8.6\") // Placeholder\n        return nil\n    }\n\n    // Set shell version (via environment variable)\n    version := args[0]\n    // Call internal/version.SetShellVersion(version)\n    return nil\n}\n```\n\n**Dependencies:**\n- `fmt`, `os`\n- `internal/version` (implementation in other spec)\n- `internal/config` (paths, validation)\n\n### Component 6: Install Command (install.go)\n\n**Purpose:** Install Maven versions or list available versions\n\n**Interfaces:**\n```go\n// NewInstallCmd creates the install command\nfunc NewInstallCmd() *cobra.Command\n\n// runInstall executes the install command\nfunc runInstall(cmd *cobra.Command, args []string) error\n```\n\n**Implementation:**\n```go\nfunc NewInstallCmd() *cobra.Command {\n    cmd := &cobra.Command{\n        Use:   \"install [version...]\",\n        Short: \"Install one or more Maven versions\",\n        RunE:  runInstall,\n    }\n    cmd.Flags().BoolP(\"list\", \"l\", false, \"List available versions\")\n    cmd.Flags().BoolP(\"quiet\", \"q\", false, \"Suppress non-error output\")\n    return cmd\n}\n\nfunc runInstall(cmd *cobra.Command, args []string) error {\n    list, _ := cmd.Flags().GetBool(\"list\")\n    quiet, _ := cmd.Flags().GetBool(\"quiet\")\n\n    if list {\n        // List available versions\n        // Call internal/version.ListAvailable()\n        fmt.Println(\"3.9.4\")\n        fmt.Println(\"3.8.6\")\n        fmt.Println(\"3.6.3\")\n        return nil\n    }\n\n    if len(args) == 0 {\n        return fmt.Errorf(\"Error: no version specified\")\n    }\n\n    // Install each version\n    for _, version := range args {\n        if !quiet {\n            fmt.Printf(\"Installing Maven %s...\\n\", version)\n        }\n        // Call internal/version.Install(version)\n    }\n\n    return nil\n}\n```\n\n**Dependencies:**\n- `fmt`, `os`\n- `internal/version` (install logic in other spec)\n- `internal/download` (download logic in other spec)\n\n### Component 7: Uninstall Command (uninstall.go)\n\n**Purpose:** Uninstall one or more Maven versions\n\n**Interfaces:**\n```go\n// NewUninstallCmd creates the uninstall command\nfunc NewUninstallCmd() *cobra.Command\n\n// runUninstall executes the uninstall command\nfunc runUninstall(cmd *cobra.Command, args []string) error\n```\n\n**Implementation:**\n```go\nfunc NewUninstallCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"uninstall <version...>\",\n        Short: \"Uninstall one or more Maven versions\",\n        Args:  cobra.MinimumNArgs(1),\n        RunE:  runUninstall,\n    }\n}\n\nfunc runUninstall(cmd *cobra.Command, args []string) error {\n    // Uninstall each version\n    for _, version := range args {\n        // Call internal/version.Uninstall(version)\n        fmt.Printf(\"Uninstalling Maven %s\\n\", version)\n    }\n    return nil\n}\n```\n\n**Dependencies:**\n- `fmt`, `os`\n- `internal/version` (uninstall logic in other spec)\n\n### Component 8: Utility Commands\n\n**Update Command (update.go):**\n```go\nfunc NewUpdateCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"update\",\n        Short: \"Update the cached version database\",\n        RunE:  runUpdate,\n    }\n}\n\nfunc runUpdate(cmd *cobra.Command, args []string) error {\n    // Call internal/version.UpdateCache()\n    fmt.Println(\"Updating version cache...\")\n    return nil\n}\n```\n\n**Rehash Command (rehash.go):**\n```go\nfunc NewRehashCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"rehash\",\n        Short: \"Rebuild shim executables\",\n        RunE:  runRehash,\n    }\n}\n\nfunc runRehash(cmd *cobra.Command, args []string) error {\n    // Call internal/shim.Rebuild()\n    return nil // Silent on success\n}\n```\n\n**Which Command (which.go):**\n```go\nfunc NewWhichCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"which <command>\",\n        Short: \"Display the full path to an executable\",\n        Args:  cobra.ExactArgs(1),\n        RunE:  runWhich,\n    }\n}\n\nfunc runWhich(cmd *cobra.Command, args []string) error {\n    command := args[0]\n    // Call internal/version.GetCommandPath(command)\n    fmt.Println(\"C:\\\\Users\\\\user\\\\.mvnenv\\\\versions\\\\3.9.4\\\\bin\\\\mvn.cmd\")\n    return nil\n}\n```\n\n**Latest Command (latest.go):**\n```go\nfunc NewLatestCmd() *cobra.Command {\n    return &cobra.Command{\n        Use:   \"latest [prefix]\",\n        Short: \"Show the latest installed or known version\",\n        Args:  cobra.MaximumNArgs(1),\n        RunE:  runLatest,\n    }\n}\n\nfunc runLatest(cmd *cobra.Command, args []string) error {\n    var prefix string\n    if len(args) > 0 {\n        prefix = args[0]\n    }\n    // Call internal/version.GetLatest(prefix)\n    fmt.Println(\"3.9.4\")\n    return nil\n}\n```\n\n**Dependencies:**\n- `fmt`, `os`\n- `internal/version`, `internal/shim` (implementation in other specs)\n\n## Data Models\n\n### Command Result Structure\n\n```go\n// CommandResult represents the outcome of a command execution\ntype CommandResult struct {\n    Success bool\n    Output  string\n    Error   error\n}\n```\n\n### Error Types\n\n```go\n// ErrVersionNotInstalled indicates the requested version is not installed\nvar ErrVersionNotInstalled = errors.New(\"version not installed\")\n\n// ErrInvalidVersion indicates an invalid version format\nvar ErrInvalidVersion = errors.New(\"invalid version format\")\n\n// ErrNoVersionSet indicates no Maven version is currently set\nvar ErrNoVersionSet = errors.New(\"no Maven version set\")\n```\n\n## Error Handling\n\n### Error Scenarios\n\n**1. No Version Set**\n- **Handling:** Return nil (not an error), print \"No Maven version set\"\n- **User Impact:** User sees informative message, exit code 0\n\n**2. Version Not Installed**\n- **Handling:** Return error with message \"Error: version 'X.Y.Z' not installed\"\n- **User Impact:** Error to stderr, exit code 1\n\n**3. Invalid Command**\n- **Handling:** Cobra automatically suggests similar commands\n- **User Impact:** \"mvnenv: no such command 'instal'. Did you mean 'install'?\"\n\n**4. Invalid Arguments**\n- **Handling:** Return error with usage hint\n- **User Impact:** Error message + usage syntax, exit code 2\n\n**5. Internal Operation Failure**\n- **Handling:** Wrap error with context, return to Cobra\n- **User Impact:** \"Error: failed to install version: <specific error>\"\n\n### Error Formatting Pattern\n\n```go\n// formatError wraps an error with \"Error: \" prefix for consistency\nfunc formatError(err error) error {\n    if err == nil {\n        return nil\n    }\n    return fmt.Errorf(\"Error: %w\", err)\n}\n\n// Usage in commands:\nfunc runGlobal(cmd *cobra.Command, args []string) error {\n    version := args[0]\n    if err := setGlobalVersion(version); err != nil {\n        return formatError(err) // Ensures \"Error: \" prefix\n    }\n    return nil\n}\n```\n\n### Quiet Flag Handling\n\n```go\n// shouldPrint checks if output should be printed based on --quiet flag\nfunc shouldPrint(cmd *cobra.Command) bool {\n    quiet, _ := cmd.Flags().GetBool(\"quiet\")\n    return !quiet\n}\n\n// Usage:\nfunc runInstall(cmd *cobra.Command, args []string) error {\n    if shouldPrint(cmd) {\n        fmt.Println(\"Installing Maven 3.9.4...\")\n    }\n    // ... installation logic\n    return nil\n}\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Test Structure:**\nEach command file has a corresponding test file:\n- `version.go` → `version_test.go`\n- `install.go` → `install_test.go`\n- etc.\n\n**Test Coverage:**\n1. **Command Construction:** Verify each NewXxxCmd returns valid cobra.Command\n2. **Flag Parsing:** Test all flags parse correctly\n3. **Argument Validation:** Test arg count validation (MinimumNArgs, MaximumNArgs)\n4. **Help Text:** Verify help includes usage, description, examples\n5. **Error Handling:** Test error messages format correctly\n\n**Example Test:**\n```go\nfunc TestNewVersionCmd(t *testing.T) {\n    cmd := NewVersionCmd()\n\n    assert.Equal(t, \"version\", cmd.Use)\n    assert.NotEmpty(t, cmd.Short)\n    assert.NotNil(t, cmd.RunE)\n}\n\nfunc TestVersionCmd_NoVersionSet(t *testing.T) {\n    // Mock internal/version to return no version\n    // Execute command\n    // Assert output is \"No Maven version set\"\n    // Assert exit code 0\n}\n\nfunc TestVersionCmd_WithVersion(t *testing.T) {\n    // Mock internal/version to return \"3.9.4\"\n    // Execute command\n    // Assert output is \"3.9.4\"\n    // Assert exit code 0\n}\n```\n\n### Integration Testing\n\n**Test Scenarios:**\n1. **Full Command Execution:** Run commands end-to-end with temporary filesystem\n2. **Flag Combinations:** Test --quiet, -h, -l flags in various combinations\n3. **Error Paths:** Trigger errors and verify output goes to stderr\n4. **Multiple Arguments:** Test install/uninstall with multiple versions\n\n**Test Approach:**\n```go\nfunc TestInstallCommand_Integration(t *testing.T) {\n    // Setup temporary .mvnenv directory\n    tmpDir := t.TempDir()\n    os.Setenv(\"MVNENV_ROOT\", tmpDir)\n\n    // Execute install command\n    rootCmd := initRootCmd()\n    rootCmd.SetArgs([]string{\"install\", \"-l\"})\n\n    // Capture output\n    output := captureOutput(func() {\n        err := rootCmd.Execute()\n        assert.NoError(t, err)\n    })\n\n    // Verify output contains version list\n    assert.Contains(t, output, \"3.9.4\")\n}\n```\n\n### End-to-End Testing\n\n**Test User Scenarios:**\n1. **Fresh Install:** User runs mvnenv commands in clean environment\n2. **Version Switching:** User switches between global/local/shell versions\n3. **Error Recovery:** User provides invalid input, sees helpful errors\n4. **Help Discovery:** User explores commands via help\n\n**E2E Test Structure:**\n```go\nfunc TestE2E_FirstTimeUser(t *testing.T) {\n    // 1. User runs mvnenv --help\n    // Verify: Command list displayed\n\n    // 2. User runs mvnenv version\n    // Verify: \"No Maven version set\"\n\n    // 3. User runs mvnenv install -l\n    // Verify: Available versions listed\n\n    // 4. User runs mvnenv global 3.9.4\n    // Verify: Silent success\n\n    // 5. User runs mvnenv version\n    // Verify: Shows \"3.9.4\"\n}\n```\n\n### Performance Testing\n\n**Benchmark Tests:**\n```go\nfunc BenchmarkVersionCommand(b *testing.B) {\n    cmd := NewVersionCmd()\n    for i := 0; i < b.N; i++ {\n        cmd.RunE(cmd, []string{})\n    }\n}\n\n// Verify: Execution time < 100ms per requirement\n```\n\n## Implementation Notes\n\n### Cobra Best Practices\n\n1. **Use RunE instead of Run** for error returns\n2. **Set SilenceErrors and SilenceUsage** on root to control error display\n3. **Use cobra.MinimumNArgs, cobra.ExactArgs** for argument validation\n4. **Use PersistentFlags** for flags inherited by subcommands\n5. **Set Hidden=true** for commands not in `mvnenv commands` output\n\n### Output Best Practices\n\n1. **Normal output to stdout:** `fmt.Println()`, `fmt.Printf()`\n2. **Errors to stderr:** `fmt.Fprintln(os.Stderr, ...)`\n3. **No output on success** for setter commands (global, local, shell)\n4. **Respect --quiet flag** for all non-error output\n5. **No colors or emojis** in any output\n\n### Placeholder Pattern\n\nFor this spec (CLI framework only), business logic calls are placeholders:\n\n```go\n// Placeholder until core-version-management spec implemented\nfmt.Println(\"3.9.4\")\n\n// Will become:\n// resolver := version.NewResolver()\n// ver, err := resolver.GetCurrentVersion()\n// if err != nil { return err }\n// fmt.Println(ver)\n```\n\nThis allows implementing and testing CLI framework independently before business logic is ready.\n",
  "fileStats": {
    "size": 25119,
    "lines": 896,
    "lastModified": "2025-10-12T02:01:41.874Z"
  },
  "comments": []
}